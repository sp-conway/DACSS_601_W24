{
  "hash": "16f604d99f4319b1e2b8d2473ca25193",
  "result": {
    "markdown": "---\ntitle: \"Functional programming\"\nauthor: \"Sean Conway\"\neditor: visual\ndescription: \"Functional programming\"  \ndate: \"1/24/2024\"\neditor_options: \n  chunk_output_type: console\nformat:\n  html:\n    df-print: paged\n    toc: true\n    code-fold: false\n    code-copy: true\n    code-tools: true\n    css: \".../styles.scss\"\ncategories:\n  - functions\n  - functional_programming\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nknitr::opts_chunk$set(echo = T)\nlibrary(tidyverse)\n```\n:::\n\n\n## Overview\n\nToday we're going to discuss functional programming in `R`.\n\nAs discussed in the functions lecture, most `R` tasks are built around using a function to perform operations.\n\nWe'll discuss how to use functions when working with a dataset, iteration, and the `purrr` package.\n\n## `across()`\n\nWe've discussed `across()` before, but we'll go over it again because it is a helpful tool when programming with functions.\n\nImagine you want to compute the [standard error](https://en.wikipedia.org/wiki/Standard_error) for each numerical variable in your variable. In our case, we'll be working with the `mtcars` data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars1 <- mtcars %>%\n  mutate(across(c(cyl,vs,am,gear,carb),as.factor))\n```\n:::\n\n\nFirst, we write a function to do so.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncompute_se <- function(x){\n  n <- length(x)\n  se <- sd(x)/sqrt(n)\n  return(se)\n}\n```\n:::\n\n\nWe could run an operation like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars1 %>%\n  summarise(\n    se_mpg=compute_se(mpg),\n    se_disp=compute_se(disp),\n    se_hp=compute_se(hp),\n    se_drat=compute_se(drat),\n    se_wt=compute_se(wt),\n    se_qsec=compute_se(qsec)\n  )\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"se_mpg\"],\"name\":[1],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"se_disp\"],\"name\":[2],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"se_hp\"],\"name\":[3],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"se_drat\"],\"name\":[4],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"se_wt\"],\"name\":[5],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"se_qsec\"],\"name\":[6],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"1.065424\",\"2\":\"21.90947\",\"3\":\"12.12032\",\"4\":\"0.09451874\",\"5\":\"0.1729685\",\"6\":\"0.3158899\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\nHowever, there's a way to be more efficient with our code, using `across()`.\n\nWe can use the selection helper `where()` to select all numeric variables, using the function `is.numeric()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars1 %>%\n  summarise(across(where(is.numeric),compute_se))\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"mpg\"],\"name\":[1],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"disp\"],\"name\":[2],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"hp\"],\"name\":[3],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"drat\"],\"name\":[4],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wt\"],\"name\":[5],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"qsec\"],\"name\":[6],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"1.065424\",\"2\":\"21.90947\",\"3\":\"12.12032\",\"4\":\"0.09451874\",\"5\":\"0.1729685\",\"6\":\"0.3158899\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\nWe can even run multiple functions at once by wrapping them in a `list()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars_summary <- mtcars1 %>%\n  summarise(across(where(is.numeric),list(mean=mean,se=compute_se)))\nmtcars_summary\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"mpg_mean\"],\"name\":[1],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"mpg_se\"],\"name\":[2],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"disp_mean\"],\"name\":[3],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"disp_se\"],\"name\":[4],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"hp_mean\"],\"name\":[5],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"hp_se\"],\"name\":[6],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"drat_mean\"],\"name\":[7],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"drat_se\"],\"name\":[8],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wt_mean\"],\"name\":[9],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wt_se\"],\"name\":[10],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"qsec_mean\"],\"name\":[11],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"qsec_se\"],\"name\":[12],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"20.09062\",\"2\":\"1.065424\",\"3\":\"230.7219\",\"4\":\"21.90947\",\"5\":\"146.6875\",\"6\":\"12.12032\",\"7\":\"3.596563\",\"8\":\"0.09451874\",\"9\":\"3.21725\",\"10\":\"0.1729685\",\"11\":\"17.84875\",\"12\":\"0.3158899\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\nNow, imagine this in a data pipeline, going from summary -\\> pivoting -\\> visualization. Say you want to visualize the mean and se for each numeric variable, split by `am` (automatic vs. manual transmission). This can be easily done using a data pipeline beginning with `summarise(across())`. \\\nFirst, we recode `am` to have more informative labels. Then we compute mean and se for each transmission type.\n\nNext, we do some data manipulation so each row is a distinct transmission type and variable, and then we compute the lower and upper ends of our error bars by subtracting and adding `se` from `mean`, respectively.\n\nFinally, we make a plot using ggplot.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars1 %>%\n  mutate(am=recode(am,`0`=\"automatic\",`1`=\"manual\")) %>%\n  group_by(am) %>%\n  summarise(across(where(is.numeric),list(mean=mean,se=compute_se))) %>%\n  ungroup() %>%\n  pivot_longer(-am) %>%\n  separate(name,into=c(\"variable\",\"stat\")) %>%\n  pivot_wider(names_from = stat,values_from = value) %>%\n  mutate(se_lower=mean-se,se_upper=mean+se) %>%\n  ggplot(aes(am,mean))+\n  geom_col(position=\"dodge\",fill=\"lightblue\")+\n  geom_errorbar(aes(ymin=se_lower,ymax=se_upper),width=.2)+\n  facet_wrap(vars(variable),scales=\"free_y\")+\n  ggthemes::theme_few()\n```\n\n::: {.cell-output-display}\n![](example-functional_programming_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\nNote that we did all of this without copy and pasting code, writing for loops, or making separate dataframes for each variable we summarized.\n\n## For loops  \n\nIf you've programmed in other languages, you're probably very familiar with for loops.\n\nFor loops are a way to perform an operation on each discrete element of a set of data.\n\nBelow, I demonstrate how for loops work in `R`, computing a [*z-score*](https://en.wikipedia.org/wiki/Standard_score)for each value in a numeric variable.\n\nI take a sample of size `n` (`n`=100 in our case) from a normal distribution, using the `rnorm()` function.\n\nThen, I initiate a numeric vector of size `n` called `xz` .\n\nFinally, a compute a z-score for each element *i* in `x`, by subtracting the mean of `x` from `x[i]` and dividing by the `sd` of `x`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 100\nx <- rnorm(n)\nxz <- numeric(n)\nfor(i in seq_len(n)){\n  xz[i] <- (x[i]-mean(x))/sd(x)\n}\nhead(xz)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -1.2936301  2.4775659  0.5575291 -0.9882565  1.6102698 -2.6284810\n```\n:::\n\n```{.r .cell-code}\nmean(xz) # should be very close to 0\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2.371801e-17\n```\n:::\n:::\n\n\nYou may be very familiar with for loops. Indeed, you may have coded in languages where a for loop is the *only* way to perform an operation like this.\n\nHowever, for loops are not always necessary in `R` due to `R`'s emphasis on *vectorized* functions - functions that automatically perform an operation on each element of a vector.\n\nI demonstrate this below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncompute_z <- function(x){\n  z <- (x-mean(x))/sd(x)\n  return(z)\n}\nn <- 100\nx1 <- rnorm(n)\nx1z <- compute_z(x1)\nhead(x1z)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -0.4312997 -0.2697905  0.3871747  0.9597387  0.1998592 -0.5565453\n```\n:::\n:::\n\n\nIndeed, the `compute_z()` function automatically does this for us.\n\nThere are indeed situations where a for loop is needed. However, the `purrr` package can often be a great substitute.\n\n## `purrr`  \n\nThe `purrr` package is used to *iterate* over multiple objects, much like a for loop. However, the syntax is more succinct, more readable, and `purrr` is often faster.\n\nImagine you want to take 50 samples of size 100 from a normal distribution, each with a different mean. We can easily do so with `purrr`'s `map()` functions. We first specify the elements we're iterating over, `means`, then we specify the function we are using, `rnorm()`, then specifying any other arguments the function needs (`n`).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmeans <- seq(10,59,1)\nn <- 100\nsamps <- map(means, rnorm, n=100)\n```\n:::\n\n\n`purrr` can also take a number of return types. That is, you can specify whether the function will return a dataframe, a vector of characters, etc. See [this link](https://purrr.tidyverse.org/articles/base.html) for more details.\n\n## Conclusion\n\nThis has provided an introduction to functional programming in `R`. There's plenty more to be said, but this demonstrates the way functions provide the backbone for most `R` operations.\n",
    "supporting": [
      "example-functional_programming_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"../site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}