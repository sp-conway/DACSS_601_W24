{
  "hash": "382ef40cd5488d242034311fcc0aae40",
  "result": {
    "markdown": "---\ntitle: \"Functions\"\nauthor: \"Sean Conway\"\neditor: visual\ndescription: \"Functions\"  \ndate: \"1/22/2024\"\neditor_options: \n  chunk_output_type: console\nformat:\n  html:\n    df-print: paged\n    toc: true\n    code-fold: false\n    code-copy: true\n    code-tools: true\n    css: \".../styles.scss\"\ncategories:\n  - functions\n  - functional_programming\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nknitr::opts_chunk$set(echo = T)\nlibrary(tidyverse)\n```\n:::\n\n\n## Overview\n\nToday we're going to discuss functions in `R`. Specifically, we will discuss how to write our own *custom* functions.\n\n## Functions\n\nA function is an object in `R` that performs a specific task. Unlike languages like Python, `R` is largely built around *functional* programming, where individual functions are used to perform data analysis tasks.[^1]\n\n[^1]: `R` does have multiple object-oriented programming systems. However, these topics are well outside the scope of this class, and these systems are largely used by developers, rather than regular users. For more info, see the [OOP section](https://adv-r.hadley.nz/oo.html) of Hadley Wickham's Advanced R book.\n\nBase `R` has many built-in functions, and the `tidyverse` packages we use provide a crucial supplement to these. However, sometimes you need to write your own functions. A good example of this is when you would otherwise need to copy and paste the same code multiple times. In this case, it's generally better to write a function.\n\nTo demonstrate function syntax, below is a simple function that takes a single required argument, `x`.\n\nThe function adds 1 to `x`, stores it in a new object, `y` and returns the new value (using a \"return\" statement).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_1 <- function(x){\n  y <- x+1\n  return(y) # return statements are not always needed, but it's good to make it explicit to avoid mistakes\n}\nval <- add_1(4) # returns a vector of length 1 (also called a scalar)\nval\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n:::\n\n\nObjects defined within the function stay within the function scope, unless returned and stored in the global environment. Bote that `y` in the `add_1()` function never makes its way to our global environment.\n\nA function can take as many arguments as you like. It can even take **zero** arguments!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhello_world <- function() {\n  print(\"hello world!\") # here we don't need a return statement, as there's nothing to return\n}\n```\n:::\n\n\nA function can have **REQUIRED** arguments (i.e., the function will not run unless the user defines them) or **OPTIONAL** arguments (i.e., the argument has a default value unless the user defines it)\n\nBelow is a new function, `add_val()`, that always adds a value to its input. By default, it adds 5, but the user can modify the optional argument `val` to specify an value to be added.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_val <- function(x, val=5){\n  y <- x+val\n  return(y)\n}\nadd_val(5) # automatically adds 5\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10\n```\n:::\n\n```{.r .cell-code}\nadd_val(x=5,val=2) # val is defined as 2, so now adds 5 + 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 7\n```\n:::\n:::\n\n\nIf your function is simple (i.e., only needs one line of code), you don't need to use the bracket syntax.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_2 <- function(x) x+2 \nadd_2(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 7\n```\n:::\n:::\n\n\n*Buuuuut* it's probably best to do it in multiple lines and include a return statement.\n\nFinally, note that many functions in `R` are **vectorized**. This means that they automatically perform their operation on each individual element of a vector.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# our \"add_val\" function is automatically vectorized\nx_1 <- c(1,4,3,1,2,4,2)\nadd_val(x=x_1,val=3) # adds 3 to each value in x_1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4 7 6 4 5 7 5\n```\n:::\n:::\n\n\n## A more concrete example  \n\nSo far, the functions we've created have been trivial. They perform tasks so trivial that you would probably never create a function to do so.\n\nHowever, let's try something more technical: a function to determine the **mode** of a categorical variable.\n\nThere is an `R` function called `mode()`, though as some students have noted, this does not actually compute the mode. Rather, it simply returns the storage mode of an `R` object.\n\nThe function `compute_mode()` computes the mode of a categorical variable. I put in some safeguards to ensure the function will return multiple values in the event of a tie. Moreover, the function actually returns a tibble. This was done to make it easier to use the function to program with tidyverse (though it would still work fine without it).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncompute_mode <- function(x, return_count=T){\n  freqs <- table(x)\n  max_n <- max(freqs)\n  mode <- names(freqs[which(freqs==max_n)])\n  if(return_count){\n    tibble(\n      mode=mode,\n      count=max_n\n    )\n  }else{\n    tibble(mode=mode)\n  }\n}\n```\n:::\n\n\n## Conclusion  \n\nThis has been an introduction to the world of writing your own functions. It is not always necessary to do so, but when you do, it's helpful to understand the syntax and rules of custom functions in `R`.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"../site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}